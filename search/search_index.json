{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Compose Lints","text":"<p>This repository contains a collection of custom lint checks for Jetpack Compose, mostly ported from the original twitter/compose-rules project.</p> <p>These checks are to ensure that your composables don\u2019t fall into common pitfalls that may be easy to miss in code reviews.</p>"},{"location":"#why","title":"Why","text":"<p>Originally from twitter/compose-rules.</p> <p>It can be challenging for big teams to start adopting Compose, particularly because not everyone will start at same time or with the same patterns. Twitter tried to ease the pain by creating a set of Compose static checks.</p> <p>Compose has lots of superpowers but also has a bunch of footguns to be aware of as seen in this Twitter Thread.</p> <p>This is where our static checks come in. We want to detect as many potential issues as we can, as quickly as we can. In this case we want an error to show prior to engineers having to review code. Similar to other static check libraries we hope this leads to a \u201cdon\u2019t shoot the messengers\u201d philosophy which will foster healthy Compose adoption.</p>"},{"location":"#installation","title":"Installation","text":"<p>Just add the dependency to the <code>lintChecks</code> configuration. Note for non-android projects, you must apply the <code>com.android.lint</code> Gradle plugin to use this.</p> <p></p> <pre><code>dependencies {\n  lintChecks(\"com.slack.lint.compose:compose-lint-checks:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2023 Salesforce, Inc.\nCopyright 2022 Twitter, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#142","title":"1.4.2","text":"<p>2024-10-22</p> <ul> <li>Enhancement: Better handle name shadowing in <code>SlotReused</code> lint and reduce false positives.</li> <li>Test against lint <code>31.8.0-alpha07</code>.</li> <li>Various doc fixes.</li> <li>Build against lint <code>31.7.1</code>.</li> <li>Build against Kotlin <code>2.0.21</code>. Still targeting Kotlin 1.9 language version (lint 31.7.x\u2019s language version).</li> </ul> <p>Special thanks to @SimonMarquis and @AlexVanyo for contributing to this release!</p>"},{"location":"changelog/#141","title":"1.4.1","text":"<p>2024-10-02</p> <ul> <li>Fix: Fix false positives reported by <code>ComposeContentEmitterReturningValues</code>.</li> <li>Fix: Fix <code>content-emitters</code> configuration in docs.</li> <li>Fix: Fix link to multipreview annotations in docs.</li> </ul> <p>Special thanks to @erikghonyan for contributing to this release!</p>"},{"location":"changelog/#140","title":"1.4.0","text":"<p>2024-10-01</p> <ul> <li>New: Implement <code>SlotReused</code> lint.  See https://slackhq.github.io/compose-lints/rules/#do-not-invoke-slots-in-more-than-once-place for more information.</li> <li>Enhancement: Report the function name for readability in <code>ComposeContentEmitterReturningValues</code>.</li> <li>Enhancement: Check for inherited <code>@Preview</code> annotations up to four levels.</li> <li>Enhancement: Allow <code>@VisibleForTesting</code>/<code>@TestOnly</code>-annotated preview composables to be public.</li> <li>Fix: Don\u2019t report duplicate errors about multiple content emitters.</li> <li>Fix: Normalize lint option loading to match with individual issues.</li> <li>Fix: Use name of parameter if text is not available.</li> <li>Removed: Delete obsolete <code>ComposeComposableModifier</code> lint check.</li> <li>Various docs fixes.</li> <li>Build against Lint <code>8.7.0</code>.</li> <li>Update <code>api</code> and <code>minApi</code> to <code>16</code> (i.e. lint 8.7.0+). It\u2019s possible this may work with API 15 but we have not tested it.</li> <li>Test against Lint <code>8.8.0-alpha04</code>.</li> <li>Test against K2 UAST.</li> <li>Build against Kotlin <code>2.0.20</code>.</li> </ul> <p>Special thanks to @alexvanyo, @seve-andre, @svenjacobs, @ychescale9, @shahzadansari, and @kozaxinan for contributing to this release!</p>"},{"location":"changelog/#131","title":"1.3.1","text":"<p>2024-01-25</p> <ul> <li>Lower the lint API back to <code>14</code>, not <code>15</code>.</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":"<p>2024-01-25</p> <ul> <li>New: Implement <code>ModifierComposed</code> check to lint against use of <code>Modifier.composed</code>, which is no longer recommended in favor of the new <code>Modifier.Node</code> API.</li> <li>New: Implement <code>ComposeUnstableReceiver</code> check to warn when composable extension functions or composables instance functions have unstable receivers/containing classes.</li> <li>New: Check for property accessors with composition locals.</li> <li>Enhancement: The <code>ComposeComposableModifier</code> message now recommends the new <code>Modifier.Node</code> API.</li> <li>Enhancement: Make lints significantly more robust to edge cases like typealiases, import aliases, parentheses, fully-qualified references, and whitespace. Our tests now cover all these cases.</li> <li>Enhancement: Update <code>@Preview</code> detection to also detect Compose Desktop\u2019s own <code>@Preview</code> annotation.</li> <li>Enhancement: Improve the <code>ComposeParameterOrder</code> check to only lint the parameter list and add a quickfix.</li> <li>Enhancement: Add support for checking for loops in multiple content emitters.</li> <li>Fix: Fix allowed names config for Unit-returning functions.</li> <li>Fix: Ignore context receivers in multiple content emissions lint.</li> <li>Fix: Allow nullable types for trailing lambdas in <code>ComposeParameterOrder</code>.</li> <li>Fix: Best-effort work around name mangling when comparing name in M2ApiDetector\u2019s allow list.</li> <li>Fix: Fix <code>ComposePreviewPublic</code> to always just require private, remove preview parameter configuration.</li> <li>Docs: Improve docs for <code>ComposeContentEmitterReturningValues</code></li> <li>Build against lint-api <code>31.2.2</code>.</li> <li>Test against lint-api <code>31.4.0-alpha06</code>.</li> <li>Raise Kotlin apiVersion/languageVersion to <code>1.9.0</code>.</li> </ul> <p>Special thanks to @jzbrooks, @joeMalebe, @dellisd for contributing to this release!</p>"},{"location":"changelog/#120","title":"1.2.0","text":"<p>2023-04-19</p> <ul> <li>Fix: Only run <code>ComposeM2Api</code> checks on Kotlin files.</li> <li>Update lint current and min API to 14, aka AGP 8.0.0+.</li> </ul>"},{"location":"changelog/#111","title":"1.1.1","text":"<p>2023-03-08</p> <ul> <li>Fix: Use <code>setEnabledByDefault(false)</code> instead of <code>IGNORE</code> in <code>ComposeM2Api</code>. This is what we intended before, too, but didn\u2019t realize there was a dedicated API for it. Note that this changes configuration slightly as you must now explicitly enable the rule too and not just the severity. See the docs: https://slackhq.github.io/compose-lints/rules/#use-material-3.</li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":"<p>2023-03-07</p> <ul> <li>New: Add <code>ComposeM2Api</code> rule. This rule can be used to lint against using \u201cMaterial 2\u201d (<code>androidx.compose.material</code>) APIs in codebases that have migrated to Material 3 (M3). This rule is disabled by default, see the docs for more information: https://slackhq.github.io/compose-lints/rules/#use-material-3.</li> <li>Enhancement: Add <code>viewmodel-factories</code> lint option to <code>ComposeViewModelInjection</code>. This allows you to define your own known ViewModel factories. Thanks to @WhosNickDoglio for contributing this!</li> <li>Build against lint-api to <code>30.4.2</code>.</li> <li>Test against lint <code>31.1.0-alpha08</code>.</li> </ul>"},{"location":"changelog/#101","title":"1.0.1","text":"<p>2023-02-15</p>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Add installation instructions to index.md by @ZacSweers in https://github.com/slackhq/compose-lints/pull/44</li> <li>Fix possible typo in README by @WhosNickDoglio in https://github.com/slackhq/compose-lints/pull/45</li> <li>Hopefully fix publish-docs actions by @chrisbanes in https://github.com/slackhq/compose-lints/pull/47</li> <li>Update lint-latest to v31.1.0-alpha04 by @slack-oss-bot in https://github.com/slackhq/compose-lints/pull/51</li> <li>Update dependency mkdocs-material to v9.0.12 by @slack-oss-bot in https://github.com/slackhq/compose-lints/pull/50</li> <li>Downgrade ComposeCompositionLocalUsage to warning by @chrisbanes in https://github.com/slackhq/compose-lints/pull/52</li> <li>Misc mutable parameter fixes by @ZacSweers in https://github.com/slackhq/compose-lints/pull/49</li> <li>Update plugin spotless to v6.15.0 by @slack-oss-bot in https://github.com/slackhq/compose-lints/pull/54</li> <li>Update dependency gradle to v8 by @slack-oss-bot in https://github.com/slackhq/compose-lints/pull/55</li> <li>Update Lint baseline by @chrisbanes in https://github.com/slackhq/compose-lints/pull/58</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@WhosNickDoglio made their first contribution in https://github.com/slackhq/compose-lints/pull/45</li> </ul> <p>Full Changelog: https://github.com/slackhq/compose-lints/compare/1.0.0...1.0.1</p>"},{"location":"changelog/#100","title":"1.0.0","text":"<p>2023-02-09</p> <p>Initial release!</p> <p>This is a near-full port of the original rule set to lint. It should be mostly at parity with the original rules as well.</p> <p>The lints target lint-api <code>30.4.0</code>/lint API <code>13</code> and target Java 11.</p> <p>See the docs for full usage and information: https://slackhq.github.io/compose-lints.</p> <p>Notes - <code>ComposeViewModelInjection</code> does not offer a quickfix yet. PRs welcome! - <code>ComposeUnstableCollections</code> is a warning by default rather than an error. - <code>CompositionLocalNaming</code> is not ported because this is offered in compose\u2019s bundled lint rules now.</p>"},{"location":"code-of-conduct/","title":"Code of Conduct","text":""},{"location":"code-of-conduct/#introduction","title":"Introduction","text":"<p>Diversity and inclusion make our community strong. We encourage participation from the most varied and diverse backgrounds possible and want to be very clear about where we stand.</p> <p>Our goal is to maintain a safe, helpful and friendly community for everyone, regardless of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other defining characteristic.</p> <p>This code and related procedures also apply to unacceptable behavior occurring outside the scope of community activities, in all community venues (online and in-person) as well as in all one-on-one communications, and anywhere such behavior has the potential to adversely affect the safety and well-being of community members.</p> <p>For more information on our code of conduct, please visit https://slackhq.github.io/code-of-conduct</p>"},{"location":"contributing/","title":"Contributors Guide","text":""},{"location":"contributing/#development","title":"Development","text":"<p>Check out this repo with Android Studio or IntelliJ. It\u2019s a standard gradle project and conventional to check out.</p> <p>The primary project is <code>slack-lint</code>.</p> <p>Kotlin should be used for more idiomatic use with lint APIs.</p>"},{"location":"contributing/#setup","title":"Setup","text":"<p>Be sure your devel environment has <code>ANDROID_HOME</code> defined or you\u2019ll have trouble running tests that require the Android SDK. If you\u2019ve added it and still seeing the error about not having it defined while running tests, try closing and re-opening Android Studio.</p>"},{"location":"contributing/#lint-documentation","title":"Lint Documentation","text":"<p>The Android Lint API Guide provides an excellent overview of lint\u2019s purpose, how it works, and how to author custom checks.</p>"},{"location":"contributing/#lint-guidelines","title":"Lint Guidelines","text":"<ul> <li>Limited scopes. Remember this will run in a slow build step or during the IDE, performance matters!<ul> <li>If your check only matters for java or kotlin, only run on appropriate files</li> <li>Use the smallest necessary scope. Avoid tree walking through the AST if it can be avoided, there   are usually more appropriate hooks.</li> </ul> </li> <li>Use <code>UElementHandler</code> (via overriding <code>createUastHandler()</code>) rather than overriding <code>Detector</code>   callback methods. <code>Detector</code> callback methods tend only to be useful for tricky scenarios, like   annotated elements. For basic <code>UElement</code> types it\u2019s best to just use <code>UElementHandler</code> as it affords   a standard API and is easy to conditionally avoid nested parsing.</li> <li>For testing, prefer writing source stubs directly in the test rather than extract individual files   in <code>resources</code> for stubs. Stubs in resources add friction for source glancing and tedious to   maintain, and should only be used for extremely complex source files.</li> <li>Use our <code>implementation&lt;*Detector&gt;()</code> helper functions for wiring your <code>Issue</code> information. This   is important because it will help ensure your check works in both command line and in the IDE.</li> </ul>"},{"location":"rules/","title":"Rules","text":""},{"location":"rules/#state","title":"State","text":""},{"location":"rules/#hoist-all-the-things","title":"Hoist all the things","text":"<p>Compose is built upon the idea of a unidirectional data flow, which can be summarised as: data/state flows down, and events fire up. To implement that, Compose advocates for the pattern of hoisting state upwards, enabling the majority of your composable functions to be stateless. This has many benefits, including far easier testing.</p> <p>In practice, there are a few common things to look out for:</p> <ul> <li>Do not pass ViewModels (or objects from DI) down.</li> <li>Do not pass <code>State&lt;Foo&gt;</code> or <code>MutableState&lt;Bar&gt;</code> instances down.</li> </ul> <p>Instead, pass down the relevant data to the function, and optional lambdas for callbacks.</p> <p>More information: State and Jetpack Compose</p> <p>Related rule: <code>ComposeViewModelForwarding</code></p>"},{"location":"rules/#state-should-be-remembered-in-composables","title":"State should be remembered in composables","text":"<p>Be careful when using <code>mutableStateOf</code> (or any of the other state builders) to make sure that you <code>remember</code> the instance. If you don\u2019t <code>remember</code> the state instance, a new state instance will be created when the function is recomposed.</p> <p>Related rule: <code>ComposeRememberMissing</code></p>"},{"location":"rules/#avoid-using-unstable-collections","title":"Avoid using unstable collections","text":"<p>Collections are defined as interfaces (e.g. <code>List&lt;T&gt;</code>, <code>Map&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>) in Kotlin, which can\u2019t guarantee that they are actually immutable. For example, you could write:</p> <pre><code>val list: List&lt;String&gt; = mutableListOf&lt;String&gt;()\n</code></pre> <p>The variable is constant, its declared type is not mutable but its implementation is still mutable. The Compose compiler cannot be sure of the immutability of this class as it just sees the declared type and as such declares it as unstable.</p> <p>To force the compiler to see a collection as truly \u2018immutable\u2019 you have a couple of options.</p> <p>You can use Kotlinx Immutable Collections:</p> <pre><code>val list: ImmutableList&lt;String&gt; = persistentListOf&lt;String&gt;()\n</code></pre> <p>Alternatively, you can wrap your collection in an annotated stable class to mark it as immutable for the Compose compiler.</p> <pre><code>@Immutable\ndata class StringList(val items: List&lt;String&gt;)\n// ...\nval list: StringList = StringList(yourList)\n</code></pre> <p>Note: It is preferred to use Kotlinx Immutable Collections for this. As you can see, the wrapped case only includes the immutability promise with the annotation, but the underlying List is still mutable. More info: Jetpack Compose Stability Explained, Kotlinx Immutable Collections</p> <p>Related rule: <code>ComposeUnstableCollections</code></p>"},{"location":"rules/#composables","title":"Composables","text":""},{"location":"rules/#do-not-use-inherently-mutable-types-as-parameters","title":"Do not use inherently mutable types as parameters","text":"<p>This practice follows on from the \u2018Hoist all the things\u2019 item above, where we said that state flows down. It might be tempting to pass mutable state down to a function to mutate the value.</p> <p>This is an anti-pattern though as it breaks the pattern of state flowing down, and events firing up. The mutation of the value is an event which should be modelled within the function API (a lambda callback).</p> <p>There are a few reasons for this, but the main one is that it is very easy to use a mutable object which does not trigger recomposition. Without triggering recomposition, your composables will not automatically update to reflect the updated value.</p> <p>Passing <code>ArrayList&lt;T&gt;</code>, <code>MutableState&lt;T&gt;</code>, <code>ViewModel</code> are common examples of this (but not limited to those types).</p> <p>Related rule: <code>ComposeMutableParameters</code></p>"},{"location":"rules/#unstable-receivers","title":"Unstable receivers","text":"<p>In compose, all parameters must be stable or immutable in order for a composable function to be restartable or skippable. This includes the containing class or receiver, which the compose-compiler will treat as the 0<sup>th</sup> argument. Using an unstable receiver is usually a bug, so this lint offers a warning to raise this issue.</p> <p>More info: Compose API Stability</p> <p>Related rule: <code>ComposeUnstableReceiver</code></p>"},{"location":"rules/#do-not-emit-content-and-return-a-result","title":"Do not emit content and return a result","text":"<p>Composable functions should either emit layout content, or return a value, but not both.</p> <p>If a composable should offer additional control surfaces to its caller, those control surfaces or callbacks should be provided as parameters to the composable function by the caller.</p> <p>More info: Compose API guidelines</p> <p>Related rule: <code>ComposeContentEmitterReturningValues</code></p> <p>Configuration</p> <p>To add your custom composables so they are used in this rule (things like your design system composables), you can configure a <code>content-emitters</code> option in <code>lint.xml</code>.</p> <pre><code>&lt;issue id=\"ComposeMultipleContentEmitters\"&gt;\n   &lt;option name=\"content-emitters\" value=\"CustomEmitter,AnotherEmitter\" /&gt;\n&lt;/issue&gt;\n</code></pre>"},{"location":"rules/#do-not-emit-multiple-pieces-of-content","title":"Do not emit multiple pieces of content","text":"<p>A composable function should emit either 0 or 1 pieces of layout, but no more. A composable function should be cohesive, and not rely on what function it is called from.</p> <p>You can see an example of what not to do below. <code>InnerContent()</code> emits a number of layout nodes and assumes that it will be called from a Column:</p> <pre><code>Column {\n    InnerContent()\n}\n@Composable\nprivate fun InnerContent() {\n    Text(...)\n    Image(...)\n    Button(...)\n}\n</code></pre> <p>However InnerContent could just as easily be called from a Row which would break all assumptions. Instead, InnerContent should be cohesive and emit a single layout node itself:</p> <p><pre><code>@Composable\nprivate fun InnerContent() {\n    Column {\n        Text(...)\n        Image(...)\n        Button(...)\n    }\n}\n</code></pre> Nesting of layouts has a drastically lower cost vs the view system, so developers should not try to minimize UI layers at the cost of correctness.</p> <p>There is a slight exception to this rule, which is when the function is defined as an extension function of an appropriate scope, like so: <pre><code>@Composable\nprivate fun ColumnScope.InnerContent() {\n    Text(...)\n    Image(...)\n    Button(...)\n}\n</code></pre> This effectively ties the function to be called from a Column, but is still not recommended (although permitted).</p> <p>Related rule: <code>ComposeMultipleContentEmitters</code></p> <p>Configuration</p> <p>To add your custom composables so they are used in this rule (things like your design system composables), you can configure a <code>content-emitters</code> option in <code>lint.xml</code>.</p> <pre><code>&lt;issue id=\"ComposeMultipleContentEmitters\"&gt;\n   &lt;option name=\"content-emitters\" value=\"CustomEmitter,AnotherEmitter\" /&gt;\n&lt;/issue&gt;\n</code></pre>"},{"location":"rules/#do-not-invoke-slots-in-more-than-once-place","title":"Do not invoke slots in more than once place","text":"<p>Slot parameters provide a convenient and idiomatic way to accept arbitrary content for a component.</p> <p>Callers of a component that takes a slot parameter have natural expectations about the lifecycle of that slot. Specifically, the slot should either be composed (invoked) in exactly one place, or not invoked at all. Even if there are visual or structure changes inside the component, callers expect the internal state of the slot to be preserved.</p> <p>Components should either use custom layouts to meet this expectation or <code>movableContentOf</code>.</p> <p>More information: Lifecycle expectations for slot parameters</p> <p>Related rule: <code>SlotReused</code></p>"},{"location":"rules/#naming-multipreview-annotations-properly","title":"Naming multipreview annotations properly","text":"<p>Multipreview annotations should be named by using <code>Previews</code> as suffix (or <code>Preview</code> if just one). These annotations have to be explicitly named to make sure that they are clearly identifiable as a <code>@Preview</code> alternative on its usages.</p> <p>More information: Multipreview annotations</p> <p>Related rule: <code>ComposePreviewNaming</code></p>"},{"location":"rules/#naming-composable-functions-properly","title":"Naming @Composable functions properly","text":"<p>Composable functions that return <code>Unit</code> should start with an uppercase letter. They are considered declarative entities that can be either present or absent in a composition and therefore follow the naming rules for classes.</p> <p>However, Composable functions that return a value should start with a lowercase letter instead. They should follow the standard Kotlin Coding Conventions for the naming of functions for any function annotated <code>@Composable</code> that returns a value other than <code>Unit</code></p> <p>More information: Naming Unit @Composable functions as entities and Naming @Composable functions that return values</p> <p>Related rules: <code>ComposeNamingUppercase</code>,<code>ComposeNamingLowercase</code></p> <p>Configuration</p> <p>To allow certain regex patterns of names, you can configure the <code>allowed-composable-function-names</code> option in <code>lint.xml</code>.</p> <pre><code>&lt;issue id=\"ComposeNamingUppercase,ComposeNamingLowercase\"&gt;\n   &lt;option name=\"allowed-composable-function-names\" value=\".*Presenter\" /&gt;\n&lt;/issue&gt;\n</code></pre>"},{"location":"rules/#ordering-composable-parameters-properly","title":"Ordering @Composable parameters properly","text":"<p>When writing Kotlin, it\u2019s a good practice to write the parameters for your methods by putting the mandatory parameters first, followed by the optional ones (aka the ones with default values). By doing so, we minimize the number times we will need to write the name for arguments explicitly.</p> <p>Modifiers occupy the first optional parameter slot to set a consistent expectation for developers that they can always provide a modifier as the final positional parameter to an element call for any given element\u2019s common case.</p> <p>More information: Kotlin default arguments, Modifier docs and Elements accept and respect a Modifier parameter.</p> <p>Related rule: <code>ComposeParameterOrder</code></p>"},{"location":"rules/#make-dependencies-explicit","title":"Make dependencies explicit","text":""},{"location":"rules/#viewmodels","title":"ViewModels","text":"<p>When designing composables, try to be explicit about the dependencies they take in. If you acquire a <code>ViewModel</code> or an instance from DI in the body of the composable, you are making this dependency implicit, which has the downsides of making it hard to test and harder to reuse.</p> <p>To solve this problem, you should inject these dependencies as default values in the composable function.</p> <p>Let\u2019s see it with an example.</p> <p><pre><code>@Composable\nprivate fun MyComposable() {\n    val viewModel = viewModel&lt;MyViewModel&gt;()\n    // ...\n}\n</code></pre> In this composable, the dependencies are implicit. When testing it you would need to fake the internals of viewModel somehow to be able to acquire your intended ViewModel.</p> <p>But, if you change it to pass these instances via the composable function parameters, you could provide the instance you want directly in your tests without any extra effort. It would also have the upside of the function being explicit about its external dependencies in its signature.</p> <pre><code>@Composable\nprivate fun MyComposable(\n    viewModel: MyViewModel = viewModel(),\n) {\n    // ...\n}\n</code></pre> <p>Related rule: <code>ComposeViewModelInjection</code></p>"},{"location":"rules/#compositionlocals","title":"<code>CompositionLocal</code>s","text":"<p><code>CompositionLocal</code> makes a composable\u2019s behavior harder to reason about. As they create implicit dependencies, callers of composables that use them need to make sure that a value for every CompositionLocal is satisfied.</p> <p>Although uncommon, there are legit use cases for them, so this rule provides an allowlist so that you can add your <code>CompositionLocal</code> names to it so that they are not flagged by the rule.</p> <p>Related rule: <code>ComposeCompositionLocalUsage</code></p> <p>Configuration</p> <p>To add your custom <code>CompositionLocal</code> to your allowlist, you can configure a <code>allowed-composition-locals</code> option in <code>lint.xml</code>.</p> <pre><code>&lt;issue id=\"ComposeCompositionLocalUsage\"&gt;\n   &lt;option name=\"allowed-composition-locals\" value=\"LocalEnabled,LocalThing\" /&gt;\n&lt;/issue&gt;\n</code></pre>"},{"location":"rules/#preview-composables-should-not-be-public","title":"Preview composables should not be public","text":"<p>When a composable function exists solely because it\u2019s a <code>@Preview</code>, it doesn\u2019t need to have public visibility because it won\u2019t be used in actual UI. To prevent folks from using it unknowingly, we should restrict its visibility to <code>private</code>.</p> <p>Related rule: <code>ComposePreviewPublic</code></p> <p>Note: If you are using Detekt, this may conflict with Detekt\u2019s UnusedPrivateMember rule. Be sure to set Detekt\u2019s ignoreAnnotated configuration to [\u2018Preview\u2019] for compatibility with this rule.</p>"},{"location":"rules/#modifiers","title":"Modifiers","text":""},{"location":"rules/#when-should-i-expose-modifier-parameters","title":"When should I expose modifier parameters?","text":"<p>Modifiers are the beating heart of Compose UI. They encapsulate the idea of composition over inheritance, by allowing developers to attach logic and behavior to layouts.</p> <p>They are especially important for your public components, as they allow callers to customize the component to their wishes.</p> <p>More info: Always provide a Modifier parameter</p> <p>Related rule: <code>ComposeModifierMissing</code></p> <p>Configuration</p> <p>By default, this rule will only check for modifiers in public methods. However, you can configure the threshold via using <code>visibility-threshold</code> option in <code>lint.xml</code>.</p> <pre><code>&lt;issue id=\"ComposeModifierMissing\"&gt;\n   &lt;option name=\"visibility-threshold\" value=\"only_public\" /&gt;\n&lt;/issue&gt;\n</code></pre> <p>Possible values are:</p> <ul> <li><code>only_public</code>: (default) Will check for missing modifiers only for public composables.</li> <li><code>public_and_internal</code>: Will check for missing modifiers in both public and internal composables.</li> <li><code>all</code>: Will check for missing modifiers in all composables.</li> </ul>"},{"location":"rules/#dont-re-use-modifiers","title":"Don\u2019t re-use modifiers","text":"<p>Modifiers which are passed in are designed so that they should be used by a single layout node in the composable function. If the provided modifier is used by multiple composables at different levels, unwanted behaviour can happen.</p> <p>In the following example we\u2019ve exposed a public modifier parameter, and then passed it to the root Column, but we\u2019ve also passed it to each of the descendant calls, with some extra modifiers on top:</p> <p><pre><code>@Composable\nprivate fun InnerContent(modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Text(modifier.clickable(), ...)\n        Image(modifier.size(), ...)\n        Button(modifier, ...)\n    }\n}\n</code></pre> This is not recommended. Instead, the provided modifier should only be used on the Column. The descendant calls should use newly built modifiers, by using the empty Modifier object:</p> <pre><code>@Composable\nprivate fun InnerContent(modifier: Modifier = Modifier) {\n    Column(modifier) {\n        Text(Modifier.clickable(), ...)\n        Image(Modifier.size(), ...)\n        Button(Modifier, ...)\n    }\n}\n</code></pre> <p>Related rule: <code>ComposeModifierReused</code></p>"},{"location":"rules/#modifiers-should-have-default-parameters","title":"Modifiers should have default parameters","text":"<p>Composables that accept a Modifier as a parameter to be applied to the whole component represented by the composable function should name the parameter modifier and assign the parameter a default value of <code>Modifier</code>. It should appear as the first optional parameter in the parameter list; after all required parameters (except for trailing lambda parameters) but before any other parameters with default values. Any default modifiers desired by a composable function should come after the modifier parameter\u2019s value in the composable function\u2019s implementation, keeping Modifier as the default parameter value.</p> <p>More info: Modifier documentation</p> <p>Related rule: <code>ComposeModifierWithoutDefault</code></p>"},{"location":"rules/#avoid-modifier-extension-factory-functions","title":"Avoid Modifier extension factory functions","text":"<p>Using <code>@Composable</code> builder functions for modifiers is not recommended, as they cause unnecessary recompositions. To avoid this, you should use <code>Modifier.Node</code> instead, as it limits recomposition to just the modifier instance, rather than the whole function tree.</p> <p>Composed modifiers may be created outside of composition, shared across elements, and declared as top-level constants, making them more flexible than modifiers that can only be created via a <code>@Composable</code> function call, and easier to avoid accidentally sharing state across elements.</p> <p>More info: Modifier extensions, Composed modifiers in Jetpack Compose by Jorge Castillo and Custom Modifiers</p> <p>Related rule: <code>ComposeComposableModifier</code></p>"},{"location":"rules/#migrate-to-modifiernode","title":"Migrate to <code>Modifier.Node</code>","text":"<p><code>Modifier.composed { ... }</code> is no longer recommended due to performance issues.</p> <p>You should use the <code>Modifier.Node</code> API instead, as it was designed from the ground up to be far more performant than composed modifiers.</p> <p>Related rule: <code>ComposeModifierComposed</code></p>"},{"location":"rules/#use-material-3","title":"Use Material 3","text":"<p>Rule: <code>ComposeM2Api</code></p> <p>Material 3 (M3) reached stable in October 2022. In apps that have migrated to M3, there may be <code>androidx.compose.material</code> (M2) APIs still remaining on the classpath from libraries or dependencies that can cause confusing imports due to the many similar or colliding Composable names in the two libraries. The <code>ComposeM2Api</code> rule can prevent these from being used.</p> <p>Lint Configuration</p> <p>This rule is disabled default and is opt-in.</p> <p>You can enable it via the <code>lint</code> DSL in Gradle: <pre><code>android {\n  lint {\n    enable += \"ComposeM2Api\"\n    error += \"ComposeM2Api\"\n  }\n}\n</code></pre> Or in <code>lint.xml</code>: <pre><code>&lt;lint&gt;\n  &lt;issue id=\"ComposeM2Api\" severity=\"error\"/&gt;\n&lt;/lint&gt;\n</code></pre> More lint configuration docs can be found here.</p> <p>Allow-list Configuration</p> <p>To allow certain APIs (i.e. for incremental migration), you can configure a <code>allowed-m2-apis</code> option in <code>lint.xml</code>. <pre><code>&lt;issue id=\"ComposeM2Api\"  severity=\"error\"&gt;\n   &lt;option name=\"allowed-m2-apis\" value=\"Text,Surface\" /&gt;\n&lt;/issue&gt;\n</code></pre></p> <p>Name mangling</p> <p>Kotlin will mangle the names of internal functions, which may match when resolving functions due to overloads. compose-lints will attempt to unmangle these names to match any in an allow-list, but can be disabled in case of any issues by setting the <code>enable-mangling-workaround</code> option in <code>lint.xml</code> to false. <pre><code>&lt;issue id=\"ComposeM2Api\"  severity=\"error\"&gt;\n   &lt;option name=\"enable-mangling-workaround\" value=\"false\" /&gt;\n&lt;/issue&gt;\n</code></pre></p> <p>Related docs links</p> <ul> <li>Announcement post: https://material.io/blog/material-3-compose-stable</li> <li>Docs: https://m3.material.io/develop/android/jetpack-compose</li> <li>Migration guide: https://developer.android.com/jetpack/compose/themes/material2-material3</li> <li>Guidance: https://developer.android.com/jetpack/compose/themes/material3</li> <li>Reply (primary sample app): https://github.com/android/compose-samples/tree/main/Reply</li> <li>More samples: https://github.com/android/compose-samples</li> </ul>"}]}